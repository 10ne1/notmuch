#!/usr/bin/env python
"""This is a notmuch implementation in python. It's goal is to allow running the test suite on the cnotmuch python bindings.

This "binary" honors the NOTMUCH_CONFIG environmen variable for reading a user's
notmuch configuration (e.g. the database path)

This code is licensed under the GNU GPL v3+."""
from __future__ import with_statement # This isn't required in Python 2.6
import sys, os, re, logging
from subprocess import call
from cnotmuch.notmuch import Database, Query
PREFIX=re.compile('(\w+):(.*$)')
#TODO Handle variable: NOTMUCH-CONFIG

#-------------------------------------------------------------------------
HELPTEXT="""The notmuch mail system.

Usage: notmuch <command> [args...]

Where <command> and [args...] are as follows:

	setup	Interactively setup notmuch for first use.

	new	[--verbose]

		Find and import new messages to the notmuch database.

	search	[options...] <search-terms> [...]

		Search for messages matching the given search terms.

	show	<search-terms> [...]

		Show all messages matching the search terms.

	count	<search-terms> [...]

		Count messages matching the search terms.

	reply	[options...] <search-terms> [...]

		Construct a reply template for a set of messages.

	tag	+<tag>|-<tag> [...] [--] <search-terms> [...]

		Add/remove tags for all messages matching the search terms.

	dump	[<filename>]

		Create a plain-text dump of the tags for each message.

	restore	<filename>

		Restore the tags from the given dump file (see 'dump').

	search-tags	[<search-terms> [...] ]

		List all tags found in the database or matching messages.

	help	[<command>]

		This message, or more detailed help for the named command.

Use "notmuch help <command>" for more details on each command.
And "notmuch help search-terms" for the common search-terms syntax.
"""
#-------------------------------------------------------------------------
#TODO: replace the dynamic pieces
USAGE="""Notmuch is configured and appears to have a database. Excellent!

At this point you can start exploring the functionality of notmuch by
using commands such as:

	notmuch search tag:inbox

	notmuch search to:"Sebastian Spaeth"

	notmuch search from:"Sebastian@SSpaeth.de"

	notmuch search subject:"my favorite things"

See "notmuch help search" for more details.

You can also use "notmuch show" with any of the thread IDs resulting
from a search. Finally, you may want to explore using a more sophisticated
interface to notmuch such as the emacs interface implemented in notmuch.el
or any other interface described at http://notmuchmail.org

And don't forget to run "notmuch new" whenever new mail arrives.

Have fun, and may your inbox never have much mail.
"""
#-------------------------------------------------------------------------
def quote_query_line(argv):
   #mangle arguments wrapping terms with spaces in quotes
   for i in xrange(0,len(argv)):
      if argv[i].find(' ') >= 0:
         #if we use prefix:termWithSpaces, put quotes around term
         m = PREFIX.match(argv[i])
         if m:
            argv[i] = '%s:"%s"' % (m.group(1), m.group(2))
         else:
            argv[i] = '"'+argv[i]+'"'
   return ' '.join(argv)

if __name__ == '__main__':

   # Handle command line options
   # No option 
   #-------------------------------------
   if len(sys.argv) == 1:
      print USAGE
   #-------------------------------------
   elif sys.argv[1] == 'setup':
       """ Interactively setup notmuch for first use. """
       print "Not implemented."
   #-------------------------------------
   elif sys.argv[1] == 'new':
       """ Interactively setup notmuch for first use. """
       #print "Not implemented. We cheat by calling the proper notmuch"
       call(['notmuch new'],shell=True)
   #-------------------------------------
   elif sys.argv[1] == 'help':
       if len(sys.argv) == 2: print HELPTEXT
       else: print "Not implemented"
   #-------------------------------------
   elif sys.argv[1] == 'show':
      db = Database()
      if len(sys.argv) == 2:
         #no further search term
         querystr=''
      else:
         #mangle arguments wrapping terms with spaces in quotes
         querystr = quote_query_line(sys.argv[2:])
      logging.debug("show "+querystr)
      m = Query(db,querystr).search_messages()
      for msg in m:
         print(msg.format_as_text())
   #-------------------------------------
   elif sys.argv[1] == 'new':
       #TODO: handle --verbose
       print "Not implemented."
   #-------------------------------------
   elif sys.argv[1] == 'count':
      db = Database()
      if len(sys.argv) == 2:
         #no further search term
         querystr=''
      else:
         #mangle arguments wrapping terms with spaces in quotes
         querystr = quote_query_line(sys.argv[2:])
      logging.debug("count "+querystr)
      print(Query(db,querystr).count_messages())
      
   #-------------------------------------
   elif sys.argv[1] == 'tag':
      #build lists of tags to be added and removed
      add, remove = [], []
      while not sys.argv[2]=='--' and \
            (sys.argv[2].startswith('+') or sys.argv[2].startswith('-')):
         if sys.argv[2].startswith('+'):
            #append to add list without initial +
            add.append(sys.argv.pop(2)[1:])
         else:
            #append to remove list without initial -
            remove.append(sys.argv.pop(2)[1:])
      #skip eventual '--'
      if sys.argv[2]=='--': sys.argv.pop(2)
      #the rest is search terms
      querystr = quote_query_line(sys.argv[2:])
      logging.debug("tag search-term "+querystr)
      db = Database(mode=Database.MODE.READ_WRITE)
      m  = Query(db,querystr).search_messages()
      for msg in m:
         #actually add and remove all tags
         map(msg.add_tag, add)
         map(msg.remove_tag, remove)
   #-------------------------------------
   elif sys.argv[1] == 'search-tags':
      if len(sys.argv) == 2:
         #no further search term
         print("\n".join(Database().get_all_tags()))
      else:
         #mangle arguments wrapping terms with spaces in quotes
         querystr = quote_query_line(sys.argv[2:])
         logging.debug("search-term "+querystr)
         db = Database()
         m  = Query(db,querystr).search_messages()
         print("\n".join([t for t in m.collect_tags()]))
   #-------------------------------------
   elif sys.argv[1] == 'dump':
      #TODO: implement "dump <filename>"
      if len(sys.argv) == 2:
         f = sys.stdout
      else:
         f = open(sys.argv[2],"w")
      db = Database()
      q = Query(db,'')
      q.set_sort(Query.SORT.MESSAGE_ID)
      m = q.search_messages()
      for msg in m:
         f.write("%s (%s)\n" % (msg.get_message_id(), msg.get_tags()))
   #-------------------------------------
   elif sys.argv[1] == 'restore':
      import re
      if len(sys.argv) == 2:
         print("No filename given. Reading dump from stdin.")
         f = sys.stdin
      else:
         f = open(sys.argv[2],"r")
      #split the msg id and the tags
      MSGID_TAGS = re.compile("(\S+)\s\((.*)\)$")
      db = Database(mode=Database.MODE.READ_WRITE)

      #read each line of the dump file
      for line in f:
         m = MSGID_TAGS.match(line)
         if not m:
            sys.stderr.write("Warning: Ignoring invalid input line: %s" % 
                             line)
            continue
         # split line in components and fetch message
         msg_id = m.group(1)
         new_tags= set(m.group(2).split())
         msg    = db.find_message(msg_id)

         if msg == None:
            sys.stderr.write(
               "Warning: Cannot apply tags to missing message: %s\n" % id)
            continue

         #do nothing if the old set of tags is the same as the new one
         old_tags = set(msg.get_tags())
         if old_tags == new_tags: continue

         #set the new tags
         msg.freeze()
         msg.remove_all_tags()
         for tag in new_tags: msg.add_tag(tag)
         msg.thaw()
            
   #-------------------------------------
   else:
       # unknown command
       print "Error: Unknown command '%s' (see \"notmuch help\")" % sys.argv[1]


   #TODO: implement
   """
setup
new
search	[options...] <search-terms> [...]
show	<search-terms> [...]
reply	[options...] <search-terms> [...]
restore	<filename>
   """

#!/usr/bin/env python
"""This is a notmuch implementation in python. 
It's goal is to allow running the test suite on the cnotmuch python bindings.

This "binary" honors the NOTMUCH_CONFIG environmen variable for reading a user's
notmuch configuration (e.g. the database path).

   (c) 2010 by Sebastian Spaeth <Sebastian@SSpaeth.de>
               Jesse Rosenthal <jrosenthal@jhu.edu>
   This code is licensed under the GNU GPL v3+.
"""
from __future__ import with_statement # This isn't required in Python 2.6
import sys, os, re, logging
from subprocess import call
from cnotmuch.notmuch import Database, Query
PREFIX=re.compile('(\w+):(.*$)')
#TODO Handle variable: NOTMUCH-CONFIG

#-------------------------------------------------------------------------
def get_user_email_addresses():
        """ Reads a user's notmuch config and returns his email addresses as list (name, primary_address, other_address1,...)"""
        import email.utils
        from ConfigParser import SafeConfigParser
        config = SafeConfigParser()
        conf_f = os.getenv('NOTMUCH_CONFIG',
                           os.path.expanduser('~/.notmuch-config'))
        config.read(conf_f)
        if not config.has_option('user','name'): name = ""
        else:name = config.get('user','name')

        if not config.has_option('user','primary_email'): mail = ""
        else:mail = config.get('user','primary_email')

        if not config.has_option('user','other_email'): other = []
        else:other = config.get('user','other_email').rstrip(';').split(';')

        other.insert(0, mail)
        other.insert(0, name)
        return other
#-------------------------------------------------------------------------
HELPTEXT="""The notmuch mail system.

Usage: notmuch <command> [args...]

Where <command> and [args...] are as follows:

	setup	Interactively setup notmuch for first use.

	new	[--verbose]

		Find and import new messages to the notmuch database.

	search	[options...] <search-terms> [...]

		Search for messages matching the given search terms.

	show	<search-terms> [...]

		Show all messages matching the search terms.

	count	<search-terms> [...]

		Count messages matching the search terms.

	reply	[options...] <search-terms> [...]

		Construct a reply template for a set of messages.

	tag	+<tag>|-<tag> [...] [--] <search-terms> [...]

		Add/remove tags for all messages matching the search terms.

	dump	[<filename>]

		Create a plain-text dump of the tags for each message.

	restore	<filename>

		Restore the tags from the given dump file (see 'dump').

	search-tags	[<search-terms> [...] ]

		List all tags found in the database or matching messages.

	help	[<command>]

		This message, or more detailed help for the named command.

Use "notmuch help <command>" for more details on each command.
And "notmuch help search-terms" for the common search-terms syntax.
"""
#-------------------------------------------------------------------------
#TODO: replace the dynamic pieces
USAGE="""Notmuch is configured and appears to have a database. Excellent!

At this point you can start exploring the functionality of notmuch by
using commands such as:

	notmuch search tag:inbox

	notmuch search to:"Sebastian Spaeth"

	notmuch search from:"Sebastian@SSpaeth.de"

	notmuch search subject:"my favorite things"

See "notmuch help search" for more details.

You can also use "notmuch show" with any of the thread IDs resulting
from a search. Finally, you may want to explore using a more sophisticated
interface to notmuch such as the emacs interface implemented in notmuch.el
or any other interface described at http://notmuchmail.org

And don't forget to run "notmuch new" whenever new mail arrives.

Have fun, and may your inbox never have much mail.
"""
#-------------------------------------------------------------------------
def quote_reply(oldbody ,date, from_address):
   """Transform a mail body into a quote text starting with On blah, x wrote:
   :param body: a str with a mail body
   :returns: The new payload of the email.message()
   """
   from cStringIO import StringIO

   #we get handed a string, wrap it in a file-like object
   oldbody = StringIO(oldbody)
   newbody = StringIO()

   newbody.write("On %s, %s wrote:\n" % (date, from_address))

   for line in oldbody:
      newbody.write("> " + line)

   return newbody.getvalue()
    
def format_reply(msgs):
   """Gets handed Messages() and displays the reply to them"""
   import email

   for msg in msgs:
      f = open(msg.get_filename(),"r")
      reply = email.message_from_file(f)

      #handle the easy non-multipart case:
      if not reply.is_multipart():
         reply.set_payload(quote_reply(reply.get_payload(),
                                       reply['date'],reply['from']))
      else:
         #handle the tricky multipart case
         deleted = ""
         """A string describing which nontext attachements have been deleted"""
         delpayloads = []
         """A list of payload indices to be deleted"""

         payloads = reply.get_payload()

         for i, part in enumerate(payloads):

            mime_main = part.get_content_maintype()
            if mime_main not in ['multipart', 'message', 'text']:
               deleted += "Non-text part: %s\n" % (part.get_content_type())
               payloads[i].set_payload("Non-text part: %s" % (part.get_content_type()))
               payloads[i].set_type('text/plain')
               delpayloads.append(i)
            else:
               # payloads[i].set_payload("Text part: %s" % (part.get_content_type()))
               payloads[i].set_payload(quote_reply(payloads[i].get_payload(),reply['date'],reply['from']))


         # Delete those payloads that we don't need anymore
         for i in reversed(sorted(delpayloads)):
            del payloads[i]

      #Back to single- and multipart handling

      my_addresses = get_user_email_addresses()
      used_address = None
      # filter our email addresses from all to: cc: and bcc: fields
      # if we find one of "my" addresses being used, 
      # it is stored in used_address
      for header in ['To', 'CC', 'Bcc']:
         if not header in reply:
            #only handle fields that exist
            continue
         addresses = email.utils.getaddresses(reply.get_all(header,[]))
         purged_addr = []
         for name, mail in addresses:
            if mail in my_addresses[1:]:
               used_address = email.utils.formataddr((my_addresses[0],mail))
            else:
               purged_addr.append(email.utils.formataddr((name,mail)))

         if len(purged_addr):
            reply.replace_header(header, ", ".join(purged_addr))
         else: 
            #we deleted all addresses, delete the header
            del reply[header]

      # Use our primary email address to the From
      # (save original from line, we still need it)
      orig_from = reply['From']
      del reply['From']
      reply['From'] = used_address if used_address \
          else email.utils.formataddr((my_addresses[0],my_addresses[1]))
      
      #reinsert the Subject after the From
      orig_subject = reply['Subject']
      del reply['Subject']
      reply['Subject'] = 'Re: ' + orig_subject

      # Calculate our new To: field
      new_to = orig_from
      # add all remaining original 'To' addresses
      if 'To' in reply:
         new_to += ", " + reply['To']
      del reply['To']
      reply.add_header('To', new_to)

      # Add our primary email address to the BCC
      new_bcc = my_addresses[1]
      if reply.has_key('Bcc'):
         new_bcc += ', '  + reply['Bcc']
         del reply['Bcc']
      reply['Bcc'] = new_bcc

      # Set replies 'In-Reply-To' header to original's Message-ID
      if reply.has_key('Message-ID') :
         del reply['In-Reply-To']
         reply['In-Reply-To'] = reply['Message-ID']

      #Add original's Message-ID to replies 'References' header.
      if reply.has_key('References'):
         ref = reply['References'] + ' ' +reply['Message-ID']
      else:
         ref = reply['Message-ID']
      del reply['References']
      reply['References'] = ref
      
      # Delete the original Message-ID.
      del(reply['Message-ID'])

      # filter all existing headers but a few and delete them from 'reply'
      delheaders = filter(lambda x: x not in ['From','To','Subject','CC','Bcc',
                                              'In-Reply-To', 'References',
                                              'Content-Type'],reply.keys())
      map(reply.__delitem__, delheaders)

      """
From: Sebastian Spaeth <Sebastian@SSpaeth.de>
Subject: Re: Template =?iso-8859-1?b?Zvxy?= das Kochrezept
In-Reply-To: <4A6D55F9.6040405@SSpaeth.de>
References:  <4A6D55F9.6040405@SSpaeth.de>
      """
   #return without Unixfrom
   return reply.as_string(False)
#-------------------------------------------------------------------------
def quote_query_line(argv):
   #mangle arguments wrapping terms with spaces in quotes
   for i in xrange(0,len(argv)):
      if argv[i].find(' ') >= 0:
         #if we use prefix:termWithSpaces, put quotes around term
         m = PREFIX.match(argv[i])
         if m:
            argv[i] = '%s:"%s"' % (m.group(1), m.group(2))
         else:
            argv[i] = '"'+argv[i]+'"'
   return ' '.join(argv)

if __name__ == '__main__':

   # Handle command line options
   #-------------------------------------
   # No option given, print USAGE and exit
   if len(sys.argv) == 1:
      print USAGE
   #-------------------------------------
   elif sys.argv[1] == 'setup':
       """Interactively setup notmuch for first use."""
       print "Not implemented."
   #-------------------------------------
   elif sys.argv[1] == 'new':
       """ Interactively setup notmuch for first use. """
       #print "Not implemented. We cheat by calling the proper notmuch"
       call(['notmuch new'],shell=True)
   #-------------------------------------
   elif sys.argv[1] == 'help':
       if len(sys.argv) == 2: print HELPTEXT
       else: print "Not implemented"
   #-------------------------------------
   elif sys.argv[1] == 'search':
      db = Database()
      if len(sys.argv) == 2:
         #no further search term
         querystr=''
      else:
         #mangle arguments wrapping terms with spaces in quotes
         querystr = quote_query_line(sys.argv[2:])
      logging.debug("search "+querystr)
      t = Query(db,querystr).search_threads()
      for thread in t:
         print(str(thread))
   #-------------------------------------
   elif sys.argv[1] == 'show':
      db = Database()
      out_format="text"
      if len(sys.argv) == 2:
         #no further search term
         querystr=''
      elif sys.argv[2].startswith("--format="):
         out_format = sys.argv[2].split("=")[1].strip()

         if not out_format in ("json", "text"):
            raise Exception("unknown format")

         if len(sys.argv) == 3:
            querystr = ''
         else:
            querystr = quote_query_line(sys.argv[3:])
      else:
         #mangle arguments wrapping terms with spaces in quotes
         querystr = quote_query_line(sys.argv[2:])

      logging.debug("show "+querystr)
      t = Query(db,querystr).search_threads()

      first_toplevel=True
      if out_format.lower()=="json":
         sys.stdout.write("[")

      for thrd in t:
         msgs = thrd.get_toplevel_messages()

         if not first_toplevel:
            if format.lower()=="json":
               sys.stdout.write(", ")

         first_toplevel = False

         msgs.show_messages(out_format, 0, True)

      if out_format.lower() == "json":
         sys.stdout.write("]")
      sys.stdout.write("\n")

   #-------------------------------------
   elif sys.argv[1] == 'reply':
      db = Database()
      if len(sys.argv) == 2:
         #no search term. abort
         print("Error: notmuch reply requires at least one search term.")
         sys.exit()

      #mangle arguments wrapping terms with spaces in quotes
      querystr = quote_query_line(sys.argv[2:])
      logging.debug("reply "+querystr)
      msgs = Query(db,querystr).search_messages()
      print (format_reply(msgs))

   #-------------------------------------
   elif sys.argv[1] == 'count':
      if len(sys.argv) == 2:
         #no further search term, count all
         querystr=''
      else:
         #mangle arguments wrapping terms with spaces in quotes
         querystr = quote_query_line(sys.argv[2:])
      print(Database().create_query(querystr).count_messages())
      
   #-------------------------------------
   elif sys.argv[1] == 'tag':
      #build lists of tags to be added and removed
      add, remove = [], []
      while not sys.argv[2]=='--' and \
            (sys.argv[2].startswith('+') or sys.argv[2].startswith('-')):
         if sys.argv[2].startswith('+'):
            #append to add list without initial +
            add.append(sys.argv.pop(2)[1:])
         else:
            #append to remove list without initial -
            remove.append(sys.argv.pop(2)[1:])
      #skip eventual '--'
      if sys.argv[2]=='--': sys.argv.pop(2)
      #the rest is search terms
      querystr = quote_query_line(sys.argv[2:])
      logging.debug("tag search-term "+querystr)
      db = Database(mode=Database.MODE.READ_WRITE)
      m  = Query(db,querystr).search_messages()
      for msg in m:
         #actually add and remove all tags
         map(msg.add_tag, add)
         map(msg.remove_tag, remove)
   #-------------------------------------
   elif sys.argv[1] == 'search-tags':
      if len(sys.argv) == 2:
         #no further search term
         print("\n".join(Database().get_all_tags()))
      else:
         #mangle arguments wrapping terms with spaces in quotes
         querystr = quote_query_line(sys.argv[2:])
         logging.debug("search-term "+querystr)
         db = Database()
         m  = Query(db,querystr).search_messages()
         print("\n".join([t for t in m.collect_tags()]))
   #-------------------------------------
   elif sys.argv[1] == 'dump':
      #TODO: implement "dump <filename>"
      if len(sys.argv) == 2:
         f = sys.stdout
      else:
         f = open(sys.argv[2],"w")
      db = Database()
      q = Query(db,'')
      q.set_sort(Query.SORT.MESSAGE_ID)
      m = q.search_messages()
      for msg in m:
         f.write("%s (%s)\n" % (msg.get_message_id(), msg.get_tags()))
   #-------------------------------------
   elif sys.argv[1] == 'restore':
      import re
      if len(sys.argv) == 2:
         print("No filename given. Reading dump from stdin.")
         f = sys.stdin
      else:
         f = open(sys.argv[2],"r")
      #split the msg id and the tags
      MSGID_TAGS = re.compile("(\S+)\s\((.*)\)$")
      db = Database(mode=Database.MODE.READ_WRITE)

      #read each line of the dump file
      for line in f:
         m = MSGID_TAGS.match(line)
         if not m:
            sys.stderr.write("Warning: Ignoring invalid input line: %s" % 
                             line)
            continue
         # split line in components and fetch message
         msg_id = m.group(1)
         new_tags= set(m.group(2).split())
         msg    = db.find_message(msg_id)

         if msg == None:
            sys.stderr.write(
               "Warning: Cannot apply tags to missing message: %s\n" % id)
            continue

         #do nothing if the old set of tags is the same as the new one
         old_tags = set(msg.get_tags())
         if old_tags == new_tags: continue

         #set the new tags
         msg.freeze()
         #only remove tags if the new ones are not a superset anyway
         if not (new_tags > old_tags): msg.remove_all_tags()
         for tag in new_tags: msg.add_tag(tag)
         msg.thaw()
            
   #-------------------------------------
   else:
       # unknown command
       print "Error: Unknown command '%s' (see \"notmuch help\")" % sys.argv[1]


   #TODO: implement
   """
setup
new
show	<search-terms> [...]
reply	[options...] <search-terms> [...]
restore	<filename>
   """
